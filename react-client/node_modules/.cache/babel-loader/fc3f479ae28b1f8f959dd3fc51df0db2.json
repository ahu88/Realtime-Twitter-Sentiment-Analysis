{"ast":null,"code":"var _s = $RefreshSig$();\n\n//a custom hook that creates the socket.io-client, exposes a tweet object\n//, and whenever a new tweet is received - will add to the array of all tweets\nimport { useState, useRef, useEffect } from \"react\";\nimport { io } from \"socket.io-client\";\nimport { twitterSentiment } from '../utils/sentimentAnalysis';\nconst ENDPOINT = \"http://localhost:4001/\";\n\nfunction useTweets() {\n  _s();\n\n  //* with functional components, we use the useState hook to use state variables */\n  //received tweets from server -> is an array\n  //tweets is the current state, and setTweets is a function that updates it\n  const [tweets, setTweets] = useState([]); //[] is the initial state of tweets\n\n  const socketRef = useRef(); //object returned from useRef will persist for the full lifetime of the component\n  //handle tweet events\n  //*** THIS IS LIKE THE COMPONENTDIDMOUNT FUNCTION -> RUN ON FIRST RENDER (not subsequent updates since passed in [] as second prop?) */\n\n  useEffect(async () => {\n    socketRef.current = io(ENDPOINT);\n    socketRef.current.on(\"tweet\", async tweet => {\n      if (tweets.data.length != undefined) {\n        //object that represents the tweet data to display\n        const newTweet = {\n          id: tweet.data.id,\n          text: tweet.data.text,\n          username: `@${tweet.includes.users[0].username}`,\n          sentiment: await twitterSentiment(tweet.data)\n        }; //add new tweet to array of tweets -> return this array\n\n        setTweets(tweets => [...tweets, newTweet]);\n      }\n    }); //destroy socket reference when connection is closed\n\n    return () => {\n      socketRef.current.disconnect();\n    };\n  }, []);\n  return tweets;\n}\n\n_s(useTweets, \"r8woRwXrQkN+3vmznPySVVo7QrE=\");\n\nexport default useTweets;","map":{"version":3,"sources":["E:/Documents/Side Projects/tweet-app-git/react-client/src/utils/useTweets.js"],"names":["useState","useRef","useEffect","io","twitterSentiment","ENDPOINT","useTweets","tweets","setTweets","socketRef","current","on","tweet","data","length","undefined","newTweet","id","text","username","includes","users","sentiment","disconnect"],"mappings":";;AAAA;AACA;AACA,SAASA,QAAT,EAAmBC,MAAnB,EAA2BC,SAA3B,QAA4C,OAA5C;AACA,SAAQC,EAAR,QAAiB,kBAAjB;AACA,SAAQC,gBAAR,QAA+B,4BAA/B;AAEA,MAAMC,QAAQ,GAAG,wBAAjB;;AAEA,SAASC,SAAT,GAAqB;AAAA;;AACnB;AAEA;AACA;AACA,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBR,QAAQ,CAAC,EAAD,CAApC,CALmB,CAKuB;;AAC1C,QAAMS,SAAS,GAAGR,MAAM,EAAxB,CANmB,CAMS;AAE5B;AACA;;AACAC,EAAAA,SAAS,CAAC,YAAY;AACpBO,IAAAA,SAAS,CAACC,OAAV,GAAoBP,EAAE,CAACE,QAAD,CAAtB;AACAI,IAAAA,SAAS,CAACC,OAAV,CAAkBC,EAAlB,CAAqB,OAArB,EAA8B,MAAOC,KAAP,IAAiB;AAC7C,UAAIL,MAAM,CAACM,IAAP,CAAYC,MAAZ,IAAsBC,SAA1B,EAAqC;AACnC;AACA,cAAMC,QAAQ,GAAG;AACfC,UAAAA,EAAE,EAAGL,KAAK,CAACC,IAAN,CAAWI,EADD;AAEfC,UAAAA,IAAI,EAAGN,KAAK,CAACC,IAAN,CAAWK,IAFH;AAGfC,UAAAA,QAAQ,EAAI,IAAGP,KAAK,CAACQ,QAAN,CAAeC,KAAf,CAAqB,CAArB,EAAwBF,QAAS,EAHjC;AAIfG,UAAAA,SAAS,EAAE,MAAMlB,gBAAgB,CAACQ,KAAK,CAACC,IAAP;AAJlB,SAAjB,CAFmC,CASnC;;AACAL,QAAAA,SAAS,CAAED,MAAD,IAAY,CAAC,GAAGA,MAAJ,EAAYS,QAAZ,CAAb,CAAT;AACD;AACF,KAbD,EAFoB,CAiBpB;;AACA,WAAO,MAAM;AACXP,MAAAA,SAAS,CAACC,OAAV,CAAkBa,UAAlB;AACD,KAFD;AAGD,GArBQ,EAqBN,EArBM,CAAT;AAuBA,SAAOhB,MAAP;AACD;;GAlCQD,S;;AAoCT,eAAeA,SAAf","sourcesContent":["//a custom hook that creates the socket.io-client, exposes a tweet object\r\n//, and whenever a new tweet is received - will add to the array of all tweets\r\nimport { useState, useRef, useEffect } from \"react\";\r\nimport {io} from \"socket.io-client\";\r\nimport {twitterSentiment} from '../utils/sentimentAnalysis'\r\n\r\nconst ENDPOINT = \"http://localhost:4001/\";\r\n\r\nfunction useTweets() {\r\n  //* with functional components, we use the useState hook to use state variables */\r\n\r\n  //received tweets from server -> is an array\r\n  //tweets is the current state, and setTweets is a function that updates it\r\n  const [tweets, setTweets] = useState([]); //[] is the initial state of tweets\r\n  const socketRef = useRef(); //object returned from useRef will persist for the full lifetime of the component\r\n\r\n  //handle tweet events\r\n  //*** THIS IS LIKE THE COMPONENTDIDMOUNT FUNCTION -> RUN ON FIRST RENDER (not subsequent updates since passed in [] as second prop?) */\r\n  useEffect(async () => {\r\n    socketRef.current = io(ENDPOINT)\r\n    socketRef.current.on(\"tweet\", async (tweet) => {\r\n      if (tweets.data.length != undefined) {\r\n        //object that represents the tweet data to display\r\n        const newTweet = {\r\n          id : tweet.data.id,\r\n          text : tweet.data.text,\r\n          username : `@${tweet.includes.users[0].username}`,\r\n          sentiment: await twitterSentiment(tweet.data)\r\n        }\r\n\r\n        //add new tweet to array of tweets -> return this array\r\n        setTweets((tweets) => [...tweets, newTweet]);\r\n      }\r\n    });\r\n\r\n    //destroy socket reference when connection is closed\r\n    return () => {\r\n      socketRef.current.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  return tweets;\r\n}\r\n\r\nexport default useTweets;\r\n\r\n"]},"metadata":{},"sourceType":"module"}