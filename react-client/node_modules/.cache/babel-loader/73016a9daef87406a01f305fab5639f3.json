{"ast":null,"code":"import $ from 'jquery';\n\nconst tf = require('@tensorflow/tfjs');\n\nlet model, metadata; //urls for pre-trained sentiment model\n\nconst urls = {\n  model: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/model.json',\n  metadata: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/metadata.json'\n};\nconst SentimentThreshold = {\n  Positive: 0.66,\n  Neutral: 0.33,\n  Negative: 0\n};\nconst PAD_INDEX = 0;\nconst OOV_INDEX = 2; //LOAD SENTIMENT MODEL\n\nasync function loadModel(url) {\n  try {\n    const model = await tf.loadLayersModel(url);\n    return model;\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nasync function loadMetadata(url) {\n  try {\n    const metadataJson = await fetch(url);\n    const metadata = await metadataJson.json();\n    return metadata;\n  } catch (err) {\n    console.log(err);\n  }\n} //PERFORM SENTIMENT ANALYSIS ON EACH TWEET\n\n\nasync function setupSentimentModel() {\n  model = await loadModel(urls.model);\n  metadata = await loadMetadata(urls.metadata);\n} //takes in array of tweets, gets sentiment score, determine if positive, neutral, or negative\n\n\nasync function processTwitterData(tweets) {\n  await setupSentimentModel();\n  const twitterData = [];\n  $.each(tweets, function (index, tweet) {\n    //jQuery iterate over (array, callback)\n    //console.log(\"tweet.text: \" + tweet.text);\n    const tweet_text = tweet.text.replace(/(?:https?|ftp):\\/\\/[\\n\\S]+/g, '');\n    const sentiment_score = getSentimentScore(tweet_text);\n    console.log(\"sentiment_score: \" + sentiment_score);\n    let tweet_sentiment = '';\n\n    if (sentiment_score > SentimentThreshold.Positive) {\n      tweet_sentiment = 'positive';\n    } else if (sentiment_score > SentimentThreshold.Neutral) {\n      tweet_sentiment = 'neutral';\n    } else if (sentiment_score >= SentimentThreshold.Negative) {\n      tweet_sentiment = 'negative';\n    } //console.log(\"tweet_sentiment: \" + tweet_sentiment);\n\n\n    twitterData.push({\n      sentiment: tweet_sentiment,\n      score: sentiment_score.toFixed(4),\n      tweet: tweet_text\n    });\n  });\n  console.log(\"twitterData: \" + twitterData);\n  return twitterData;\n} //\n\n\nasync function processTweetData(tweet) {\n  await setupSentimentModel();\n  let twitterData = {};\n  const tweet_text = tweet.text.replace(/(?:https?|ftp):\\/\\/[\\n\\S]+/g, '');\n  const sentiment_score = getSentimentScore(tweet_text);\n  console.log(\"sentiment_score: \" + sentiment_score);\n  let tweet_sentiment = '';\n\n  if (sentiment_score > SentimentThreshold.Positive) {\n    tweet_sentiment = 'positive';\n  } else if (sentiment_score > SentimentThreshold.Neutral) {\n    tweet_sentiment = 'neutral';\n  } else if (sentiment_score >= SentimentThreshold.Negative) {\n    tweet_sentiment = 'negative';\n  } //console.log(\"tweet_sentiment: \" + tweet_sentiment);\n\n\n  twitterData = {\n    sentiment: tweet_sentiment,\n    score: sentiment_score.toFixed(4),\n    tweet: tweet_text\n  };\n  return twitterData;\n} //gets the sentiment score of a single tweet using model.predict()\n\n\nfunction getSentimentScore(text) {\n  const inputText = text.trim().toLowerCase().replace(/(\\.|\\,|\\!)/g, '').split(' '); // Convert the words to a sequence of word indices.\n\n  const sequence = inputText.map(word => {\n    let wordIndex = metadata.word_index[word] + metadata.index_from;\n\n    if (wordIndex > metadata.vocabulary_size) {\n      wordIndex = OOV_INDEX;\n    }\n\n    return wordIndex;\n  }); // Perform truncation and padding.\n\n  const paddedSequence = padSequences([sequence], metadata.max_len);\n  const input = tf.tensor2d(paddedSequence, [1, metadata.max_len]); // ***\n\n  const predictOut = model.predict(input);\n  const score = predictOut.dataSync()[0];\n  predictOut.dispose();\n  return score;\n}\n\nfunction padSequences(sequences, maxLen, padding = 'pre', truncating = 'pre', value = PAD_INDEX) {\n  return sequences.map(seq => {\n    if (seq.length > maxLen) {\n      if (truncating === 'pre') {\n        seq.splice(0, seq.length - maxLen);\n      } else {\n        seq.splice(maxLen, seq.length - maxLen);\n      }\n    }\n\n    if (seq.length < maxLen) {\n      const pad = [];\n\n      for (let i = 0; i < maxLen - seq.length; ++i) {\n        pad.push(value);\n      }\n\n      if (padding === 'pre') {\n        seq = pad.concat(seq);\n      } else {\n        seq = seq.concat(pad);\n      }\n    }\n\n    return seq;\n  });\n} //function to run the sentiment analysis for array\n// export async function twitterSentiment(tweets) {\n//   console.log('tweets.length: ' + tweets.length);\n//   //* JAVASCRIPT WILL NOT BLOCK AND WAIT FOR FUNCTION 'processTwitterData' RETURN VALUE UNLESS YOU USE A CALLBACK!!! */\n//   // processTwitterData(tweets, function(twitterData) {\n//   //   callback(twitterData); //THIS IS ANOTHER CALLBACK FOR THE SENTIMENTPAGE INDEX.JSX\n//   // });\n//   let sentiment_data = await processTwitterData(tweets);\n//   console.log(sentiment_data);\n//   return sentiment_data;\n// }\n//function to run the sentiment analysis\n\n\nexport async function tweetSentiment(tweet) {\n  console.log(tweet);\n  let sentiment_data = await processTweetData(tweet);\n  console.log(sentiment_data);\n  return sentiment_data;\n} // //export the functions as modules so that they can be reused by other parts of the code (i.e. in index.js)\n// module.exports.loadModel = loadModel;\n// module.exports.loadMetadata = loadMetadata;\n// module.exports.processTwitterData = processTwitterData;\n// module.exports.getSentimentScore = getSentimentScore;\n// module.exports.twitterSentiment = twitterSentiment;","map":{"version":3,"sources":["E:/Documents/Side Projects/tweet-app-git/react-client/src/utils/sentimentAnalysis.js"],"names":["$","tf","require","model","metadata","urls","SentimentThreshold","Positive","Neutral","Negative","PAD_INDEX","OOV_INDEX","loadModel","url","loadLayersModel","err","console","log","loadMetadata","metadataJson","fetch","json","setupSentimentModel","processTwitterData","tweets","twitterData","each","index","tweet","tweet_text","text","replace","sentiment_score","getSentimentScore","tweet_sentiment","push","sentiment","score","toFixed","processTweetData","inputText","trim","toLowerCase","split","sequence","map","word","wordIndex","word_index","index_from","vocabulary_size","paddedSequence","padSequences","max_len","input","tensor2d","predictOut","predict","dataSync","dispose","sequences","maxLen","padding","truncating","value","seq","length","splice","pad","i","concat","tweetSentiment","sentiment_data"],"mappings":"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","sourcesContent":["import $ from 'jquery'\r\n\r\nconst tf = require('@tensorflow/tfjs');\r\n\r\nlet model, metadata;\r\n\r\n//urls for pre-trained sentiment model\r\nconst urls = {\r\n  model: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/model.json',\r\n  metadata: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/metadata.json'\r\n};\r\n\r\nconst SentimentThreshold = {\r\n  Positive: 0.66,\r\n  Neutral: 0.33,\r\n  Negative: 0\r\n}\r\n\r\nconst PAD_INDEX = 0;\r\nconst OOV_INDEX = 2;\r\n\r\n//LOAD SENTIMENT MODEL\r\nasync function loadModel(url) {\r\n  try {\r\n    const model = await tf.loadLayersModel(url);\r\n    return model;\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n}\r\n \r\nasync function loadMetadata(url) {\r\n  try {\r\n    const metadataJson = await fetch(url);\r\n    const metadata = await metadataJson.json();\r\n    return metadata;\r\n  } catch (err) {\r\n    console.log(err);\r\n  }\r\n}\r\n\r\n//PERFORM SENTIMENT ANALYSIS ON EACH TWEET\r\nasync function setupSentimentModel(){\r\n  model = await loadModel(urls.model);\r\n  metadata = await loadMetadata(urls.metadata);\r\n\r\n}\r\n\r\n//takes in array of tweets, gets sentiment score, determine if positive, neutral, or negative\r\nasync function processTwitterData(tweets) {\r\n  await setupSentimentModel();\r\n    \r\n  const twitterData = [];\r\n  $.each(tweets, function( index, tweet ) { //jQuery iterate over (array, callback)\r\n    //console.log(\"tweet.text: \" + tweet.text);\r\n\r\n    const tweet_text = tweet.text.replace(/(?:https?|ftp):\\/\\/[\\n\\S]+/g, '');\r\n    const sentiment_score = getSentimentScore(tweet_text);\r\n\r\n    console.log(\"sentiment_score: \" + sentiment_score);\r\n    let tweet_sentiment = '';\r\n    if(sentiment_score > SentimentThreshold.Positive){\r\n      tweet_sentiment = 'positive'\r\n    }else if(sentiment_score > SentimentThreshold.Neutral){\r\n      tweet_sentiment = 'neutral'\r\n    }else if(sentiment_score >= SentimentThreshold.Negative){\r\n      tweet_sentiment = 'negative'\r\n    }\r\n    \r\n    //console.log(\"tweet_sentiment: \" + tweet_sentiment);\r\n\r\n    twitterData.push({\r\n      sentiment: tweet_sentiment,\r\n      score: sentiment_score.toFixed(4),\r\n      tweet: tweet_text\r\n    });\r\n\r\n  });\r\n  console.log(\"twitterData: \" + twitterData);\r\n\r\n  return twitterData;\r\n}\r\n\r\n//\r\nasync function processTweetData(tweet) {\r\n  await setupSentimentModel();\r\n    \r\n  let twitterData = {};\r\n\r\n  const tweet_text = tweet.text.replace(/(?:https?|ftp):\\/\\/[\\n\\S]+/g, '');\r\n  const sentiment_score = getSentimentScore(tweet_text);\r\n\r\n  console.log(\"sentiment_score: \" + sentiment_score);\r\n  let tweet_sentiment = '';\r\n  if(sentiment_score > SentimentThreshold.Positive){\r\n    tweet_sentiment = 'positive'\r\n  }else if(sentiment_score > SentimentThreshold.Neutral){\r\n    tweet_sentiment = 'neutral'\r\n  }else if(sentiment_score >= SentimentThreshold.Negative){\r\n    tweet_sentiment = 'negative'\r\n  }\r\n  \r\n  //console.log(\"tweet_sentiment: \" + tweet_sentiment);\r\n\r\n  twitterData = {\r\n    sentiment: tweet_sentiment,\r\n    score: sentiment_score.toFixed(4),\r\n    tweet: tweet_text\r\n  };\r\n\r\n  return twitterData;\r\n}\r\n\r\n//gets the sentiment score of a single tweet using model.predict()\r\nfunction getSentimentScore(text) {\r\n  const inputText = text.trim().toLowerCase().replace(/(\\.|\\,|\\!)/g, '').split(' ');\r\n  // Convert the words to a sequence of word indices.\r\n  const sequence = inputText.map(word => {\r\n    let wordIndex = metadata.word_index[word] + metadata.index_from;\r\n    if (wordIndex > metadata.vocabulary_size) {\r\n    wordIndex = OOV_INDEX;\r\n    }\r\n    return wordIndex;\r\n  });\r\n  // Perform truncation and padding.\r\n  const paddedSequence = padSequences([sequence], metadata.max_len);\r\n  const input = tf.tensor2d(paddedSequence, [1, metadata.max_len]);\r\n      \r\n  // ***\r\n  const predictOut = model.predict(input);\r\n  const score = predictOut.dataSync()[0];\r\n  predictOut.dispose();\r\n \r\n  return score;\r\n}\r\n\r\nfunction padSequences(sequences, maxLen, padding = 'pre', truncating = 'pre', value = PAD_INDEX) {\r\n  return sequences.map(seq => {\r\n    if (seq.length > maxLen) {\r\n    if (truncating === 'pre') {\r\n      seq.splice(0, seq.length - maxLen);\r\n    } else {\r\n      seq.splice(maxLen, seq.length - maxLen);\r\n    }\r\n    }\r\n  \r\n    if (seq.length < maxLen) {\r\n    const pad = [];\r\n    for (let i = 0; i < maxLen - seq.length; ++i) {\r\n      pad.push(value);\r\n    }\r\n    if (padding === 'pre') {\r\n      seq = pad.concat(seq);\r\n    } else {\r\n      seq = seq.concat(pad);\r\n    }\r\n    }\r\n  \r\n    return seq;\r\n  });\r\n  }\r\n\r\n//function to run the sentiment analysis for array\r\n// export async function twitterSentiment(tweets) {\r\n//   console.log('tweets.length: ' + tweets.length);\r\n\r\n//   //* JAVASCRIPT WILL NOT BLOCK AND WAIT FOR FUNCTION 'processTwitterData' RETURN VALUE UNLESS YOU USE A CALLBACK!!! */\r\n//   // processTwitterData(tweets, function(twitterData) {\r\n//   //   callback(twitterData); //THIS IS ANOTHER CALLBACK FOR THE SENTIMENTPAGE INDEX.JSX\r\n//   // });\r\n\r\n//   let sentiment_data = await processTwitterData(tweets);\r\n//   console.log(sentiment_data);\r\n//   return sentiment_data;\r\n// }\r\n\r\n//function to run the sentiment analysis\r\nexport async function tweetSentiment(tweet) {\r\n  console.log(tweet);\r\n\r\n  let sentiment_data = await processTweetData(tweet);\r\n  console.log(sentiment_data);\r\n  return sentiment_data;\r\n}\r\n\r\n\r\n// //export the functions as modules so that they can be reused by other parts of the code (i.e. in index.js)\r\n// module.exports.loadModel = loadModel;\r\n// module.exports.loadMetadata = loadMetadata;\r\n// module.exports.processTwitterData = processTwitterData;\r\n// module.exports.getSentimentScore = getSentimentScore;\r\n// module.exports.twitterSentiment = twitterSentiment;"]},"metadata":{},"sourceType":"module"}