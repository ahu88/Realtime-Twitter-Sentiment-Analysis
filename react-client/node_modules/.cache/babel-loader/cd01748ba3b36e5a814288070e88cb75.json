{"ast":null,"code":"import $ from 'jquery';\n\nconst tf = require('@tensorflow/tfjs');\n\nlet model, metadata; //urls for pre-trained sentiment model\n\nconst urls = {\n  model: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/model.json',\n  metadata: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/metadata.json'\n};\nconst SentimentThreshold = {\n  Positive: 0.66,\n  Neutral: 0.33,\n  Negative: 0\n}; //1) LOAD SENTIMENT MODEL\n\nasync function loadModel(url) {\n  try {\n    const model = await tf.loadLayersModel(url);\n    console.log(\"YEEHAW\");\n    return model;\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nasync function loadMetadata(url) {\n  try {\n    const metadataJson = await fetch(url);\n    const metadata = await metadataJson.json();\n    return metadata;\n  } catch (err) {\n    console.log(err);\n  }\n} //2) PERFORM SENTIMENT ANALYSIS ON EACH TWEET\n\n\nasync function setupSentimentModel() {\n  if (typeof model === 'undefined') {\n    model = await loadModel(urls.model);\n  }\n\n  if (typeof metadata === 'undefined') {\n    metadata = await loadMetadata(urls.metadata);\n  }\n} //takes in array of tweets, gets sentiment score, determine if positive, neutral, or negative\n\n\nfunction processTwitterData(tweets) {\n  setupSentimentModel().then(result => {\n    const twitterData = [];\n    $.each(tweets, function (index, tweet) {\n      const tweet_text = tweet.full_text.replace(/(?:https?|ftp):\\/\\/[\\n\\S]+/g, '');\n      const sentiment_score = getSentimentScore(tweet_text);\n      let tweet_sentiment = '';\n\n      if (sentiment_score > SentimentThreshold.Positive) {\n        tweet_sentiment = 'positive';\n      } else if (sentiment_score > SentimentThreshold.Neutral) {\n        tweet_sentiment = 'neutral';\n      } else if (sentiment_score >= SentimentThreshold.Negative) {\n        tweet_sentiment = 'negative';\n      }\n\n      twitterData.push({\n        sentiment: tweet_sentiment,\n        score: sentiment_score.toFixed(4),\n        tweet: tweet_text\n      });\n    });\n    console.log(twitterData); // $('.spinner-border').addClass('d-none');\n    // displayTweets(twitterData.filter(t => t.sentiment == 'positive'), 'positive');\n    // displayTweets(twitterData.filter(t => t.sentiment == 'neutral'), 'neutral');\n    // displayTweets(twitterData.filter(t => t.sentiment == 'negative'), 'negative');\n    // $('#tweet-list').removeClass('d-none');\n    // displayPieChart(twitterData);\n  });\n} //gets the sentiment score of a single tweet using model.predict()\n\n\nfunction getSentimentScore(text) {\n  const inputText = text.trim().toLowerCase().replace(/(\\.|\\,|\\!)/g, '').split(' '); // Convert the words to a sequence of word indices.\n\n  const sequence = inputText.map(word => {\n    let wordIndex = metadata.word_index[word] + metadata.index_from;\n\n    if (wordIndex > metadata.vocabulary_size) {\n      wordIndex = OOV_INDEX;\n    }\n\n    return wordIndex;\n  }); // Perform truncation and padding.\n\n  const paddedSequence = padSequences([sequence], metadata.max_len);\n  const input = tf.tensor2d(paddedSequence, [1, metadata.max_len]);\n  const predictOut = model.predict(input);\n  const score = predictOut.dataSync()[0];\n  predictOut.dispose();\n  return score;\n} //function to run the sentiment analysis\n\n\nexport function twitterSentiment(tweets) {\n  processTwitterData(tweets);\n} // //export the functions as modules so that they can be reused by other parts of the code (i.e. in index.js)\n// module.exports.loadModel = loadModel;\n// module.exports.loadMetadata = loadMetadata;\n// module.exports.processTwitterData = processTwitterData;\n// module.exports.getSentimentScore = getSentimentScore;\n// module.exports.twitterSentiment = twitterSentiment;","map":{"version":3,"sources":["E:/Documents/Side Projects/tweet-app-git/react-client/src/utils/sentimentAnalysis.js"],"names":["$","tf","require","model","metadata","urls","SentimentThreshold","Positive","Neutral","Negative","loadModel","url","loadLayersModel","console","log","err","loadMetadata","metadataJson","fetch","json","setupSentimentModel","processTwitterData","tweets","then","result","twitterData","each","index","tweet","tweet_text","full_text","replace","sentiment_score","getSentimentScore","tweet_sentiment","push","sentiment","score","toFixed","text","inputText","trim","toLowerCase","split","sequence","map","word","wordIndex","word_index","index_from","vocabulary_size","OOV_INDEX","paddedSequence","padSequences","max_len","input","tensor2d","predictOut","predict","dataSync","dispose","twitterSentiment"],"mappings":"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","sourcesContent":["import $ from 'jquery'\r\n\r\nconst tf = require('@tensorflow/tfjs');\r\n\r\nlet model, metadata;\r\n\r\n//urls for pre-trained sentiment model\r\nconst urls = {\r\n    model: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/model.json',\r\n    metadata: 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/metadata.json'\r\n};\r\n\r\nconst SentimentThreshold = {\r\n    Positive: 0.66,\r\n    Neutral: 0.33,\r\n    Negative: 0\r\n}\r\n\r\n//1) LOAD SENTIMENT MODEL\r\nasync function loadModel(url) {\r\n    try {\r\n        const model = await tf.loadLayersModel(url);\r\n        console.log(\"YEEHAW\");\r\n        return model;\r\n    } catch (err) {\r\n        console.log(err);\r\n    }\r\n}\r\n \r\nasync function loadMetadata(url) {\r\n    try {\r\n        const metadataJson = await fetch(url);\r\n        const metadata = await metadataJson.json();\r\n        return metadata;\r\n    } catch (err) {\r\n        console.log(err);\r\n    }\r\n}\r\n\r\n//2) PERFORM SENTIMENT ANALYSIS ON EACH TWEET\r\nasync function setupSentimentModel(){\r\n    if(typeof model === 'undefined'){\r\n        model = await loadModel(urls.model);\r\n    }\r\n    if(typeof metadata === 'undefined'){\r\n        metadata = await loadMetadata(urls.metadata);\r\n    }\r\n}\r\n\r\n//takes in array of tweets, gets sentiment score, determine if positive, neutral, or negative\r\nfunction processTwitterData(tweets){\r\n    setupSentimentModel().then(\r\n        result => {\r\n            const twitterData = [];\r\n            $.each(tweets, function( index, tweet ) {\r\n                const tweet_text = tweet.full_text.replace(/(?:https?|ftp):\\/\\/[\\n\\S]+/g, '');\r\n                const sentiment_score = getSentimentScore(tweet_text);\r\n                let tweet_sentiment = '';\r\n                if(sentiment_score > SentimentThreshold.Positive){\r\n                    tweet_sentiment = 'positive'\r\n                }else if(sentiment_score > SentimentThreshold.Neutral){\r\n                    tweet_sentiment = 'neutral'\r\n                }else if(sentiment_score >= SentimentThreshold.Negative){\r\n                    tweet_sentiment = 'negative'\r\n                }\r\n                twitterData.push({\r\n                    sentiment: tweet_sentiment,\r\n                    score: sentiment_score.toFixed(4),\r\n                    tweet: tweet_text\r\n                });\r\n            });\r\n            console.log(twitterData);\r\n            // $('.spinner-border').addClass('d-none');\r\n            // displayTweets(twitterData.filter(t => t.sentiment == 'positive'), 'positive');\r\n            // displayTweets(twitterData.filter(t => t.sentiment == 'neutral'), 'neutral');\r\n            // displayTweets(twitterData.filter(t => t.sentiment == 'negative'), 'negative');\r\n            // $('#tweet-list').removeClass('d-none');\r\n            // displayPieChart(twitterData);\r\n        }\r\n    )   \r\n}\r\n\r\n//gets the sentiment score of a single tweet using model.predict()\r\nfunction getSentimentScore(text) {\r\n    const inputText = text.trim().toLowerCase().replace(/(\\.|\\,|\\!)/g, '').split(' ');\r\n    // Convert the words to a sequence of word indices.\r\n    const sequence = inputText.map(word => {\r\n      let wordIndex = metadata.word_index[word] + metadata.index_from;\r\n      if (wordIndex > metadata.vocabulary_size) {\r\n        wordIndex = OOV_INDEX;\r\n      }\r\n      return wordIndex;\r\n    });\r\n    // Perform truncation and padding.\r\n    const paddedSequence = padSequences([sequence], metadata.max_len);\r\n    const input = tf.tensor2d(paddedSequence, [1, metadata.max_len]);\r\n \r\n    const predictOut = model.predict(input);\r\n    const score = predictOut.dataSync()[0];\r\n    predictOut.dispose();\r\n \r\n    return score;\r\n}\r\n\r\n//function to run the sentiment analysis\r\nexport function twitterSentiment(tweets) {\r\n    processTwitterData(tweets);\r\n}\r\n\r\n// //export the functions as modules so that they can be reused by other parts of the code (i.e. in index.js)\r\n// module.exports.loadModel = loadModel;\r\n// module.exports.loadMetadata = loadMetadata;\r\n// module.exports.processTwitterData = processTwitterData;\r\n// module.exports.getSentimentScore = getSentimentScore;\r\n// module.exports.twitterSentiment = twitterSentiment;"]},"metadata":{},"sourceType":"module"}