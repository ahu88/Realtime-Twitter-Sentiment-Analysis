{"ast":null,"code":"var _s = $RefreshSig$();\n\n//a custom hook that creates the socket.io-client, exposes a tweet object\n//, and whenever a new tweet is received - will add to the array of all tweets\nimport { useState, useRef, useEffect } from \"react\";\nimport { io } from \"socket.io-client\";\nimport { twitterSentiment } from '../utils/sentimentAnalysis';\nconst ENDPOINT = \"http://localhost:4001/\";\n\nfunction useTweets() {\n  _s();\n\n  //* with functional components, we use the useState hook to use state variables */\n  //received tweets from server -> is an array\n  //tweets is the current state, and setTweets is a function that updates it\n  const [tweets, setTweets] = useState([]); //[] is the initial state of tweets\n\n  const socketRef = useRef(); //object returned from useRef will persist for the full lifetime of the component\n  //handle tweet events\n  //*** THIS IS LIKE THE COMPONENTDIDMOUNT FUNCTION -> RUN ON FIRST RENDER (not subsequent updates since passed in [] as second prop) */\n\n  useEffect(async () => {\n    socketRef.current = io(ENDPOINT);\n    socketRef.current.on(\"tweet\", async tweet => {\n      console.log(tweets);\n      console.log(tweet.data);\n\n      if (tweet.data != undefined) {\n        //object that represents the tweet data to display\n        const newTweet = {\n          id: tweet.data.id,\n          text: tweet.data.text,\n          username: `@${tweet.includes.users[0].username}`,\n          sentiment: await tweetSentiment(tweet.data)\n        };\n        console.log(newTweet); //add new tweet to array of tweets -> return this array\n\n        setTweets(tweets => [...tweets, newTweet]);\n        console.log(tweets);\n      }\n    }); //destroy socket reference when connection is closed\n\n    return () => {\n      socketRef.current.disconnect();\n    };\n  }, []); //console.log(tweets);\n\n  return tweets;\n}\n\n_s(useTweets, \"r8woRwXrQkN+3vmznPySVVo7QrE=\");\n\nexport default useTweets;","map":{"version":3,"sources":["E:/Documents/Side Projects/tweet-app-git/react-client/src/utils/useTweets.js"],"names":["useState","useRef","useEffect","io","twitterSentiment","ENDPOINT","useTweets","tweets","setTweets","socketRef","current","on","tweet","console","log","data","undefined","newTweet","id","text","username","includes","users","sentiment","tweetSentiment","disconnect"],"mappings":";;AAAA;AACA;AACA,SAASA,QAAT,EAAmBC,MAAnB,EAA2BC,SAA3B,QAA4C,OAA5C;AACA,SAAQC,EAAR,QAAiB,kBAAjB;AACA,SAAQC,gBAAR,QAA+B,4BAA/B;AAEA,MAAMC,QAAQ,GAAG,wBAAjB;;AAEA,SAASC,SAAT,GAAqB;AAAA;;AACnB;AAEA;AACA;AACA,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBR,QAAQ,CAAC,EAAD,CAApC,CALmB,CAKuB;;AAC1C,QAAMS,SAAS,GAAGR,MAAM,EAAxB,CANmB,CAMS;AAE5B;AACA;;AACAC,EAAAA,SAAS,CAAC,YAAY;AACpBO,IAAAA,SAAS,CAACC,OAAV,GAAoBP,EAAE,CAACE,QAAD,CAAtB;AAEAI,IAAAA,SAAS,CAACC,OAAV,CAAkBC,EAAlB,CAAqB,OAArB,EAA8B,MAAOC,KAAP,IAAiB;AAC7CC,MAAAA,OAAO,CAACC,GAAR,CAAYP,MAAZ;AACAM,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAK,CAACG,IAAlB;;AACA,UAAIH,KAAK,CAACG,IAAN,IAAcC,SAAlB,EAA6B;AAC3B;AACA,cAAMC,QAAQ,GAAG;AACfC,UAAAA,EAAE,EAAGN,KAAK,CAACG,IAAN,CAAWG,EADD;AAEfC,UAAAA,IAAI,EAAGP,KAAK,CAACG,IAAN,CAAWI,IAFH;AAGfC,UAAAA,QAAQ,EAAI,IAAGR,KAAK,CAACS,QAAN,CAAeC,KAAf,CAAqB,CAArB,EAAwBF,QAAS,EAHjC;AAIfG,UAAAA,SAAS,EAAE,MAAMC,cAAc,CAACZ,KAAK,CAACG,IAAP;AAJhB,SAAjB;AAMAF,QAAAA,OAAO,CAACC,GAAR,CAAYG,QAAZ,EAR2B,CAU3B;;AACAT,QAAAA,SAAS,CAAED,MAAD,IAAY,CAAC,GAAGA,MAAJ,EAAYU,QAAZ,CAAb,CAAT;AACAJ,QAAAA,OAAO,CAACC,GAAR,CAAYP,MAAZ;AACD;AACF,KAjBD,EAHoB,CAsBpB;;AACA,WAAO,MAAM;AACXE,MAAAA,SAAS,CAACC,OAAV,CAAkBe,UAAlB;AACD,KAFD;AAGD,GA1BQ,EA0BN,EA1BM,CAAT,CAVmB,CAsCnB;;AACA,SAAOlB,MAAP;AACD;;GAxCQD,S;;AA0CT,eAAeA,SAAf","sourcesContent":["//a custom hook that creates the socket.io-client, exposes a tweet object\r\n//, and whenever a new tweet is received - will add to the array of all tweets\r\nimport { useState, useRef, useEffect } from \"react\";\r\nimport {io} from \"socket.io-client\";\r\nimport {twitterSentiment} from '../utils/sentimentAnalysis'\r\n\r\nconst ENDPOINT = \"http://localhost:4001/\";\r\n\r\nfunction useTweets() {\r\n  //* with functional components, we use the useState hook to use state variables */\r\n\r\n  //received tweets from server -> is an array\r\n  //tweets is the current state, and setTweets is a function that updates it\r\n  const [tweets, setTweets] = useState([]); //[] is the initial state of tweets\r\n  const socketRef = useRef(); //object returned from useRef will persist for the full lifetime of the component\r\n\r\n  //handle tweet events\r\n  //*** THIS IS LIKE THE COMPONENTDIDMOUNT FUNCTION -> RUN ON FIRST RENDER (not subsequent updates since passed in [] as second prop) */\r\n  useEffect(async () => {\r\n    socketRef.current = io(ENDPOINT)\r\n    \r\n    socketRef.current.on(\"tweet\", async (tweet) => {\r\n      console.log(tweets);\r\n      console.log(tweet.data);\r\n      if (tweet.data != undefined) {\r\n        //object that represents the tweet data to display\r\n        const newTweet = {\r\n          id : tweet.data.id,\r\n          text : tweet.data.text,\r\n          username : `@${tweet.includes.users[0].username}`,\r\n          sentiment: await tweetSentiment(tweet.data)\r\n        }\r\n        console.log(newTweet);\r\n\r\n        //add new tweet to array of tweets -> return this array\r\n        setTweets((tweets) => [...tweets, newTweet]);\r\n        console.log(tweets);\r\n      }\r\n    });\r\n\r\n    //destroy socket reference when connection is closed\r\n    return () => {\r\n      socketRef.current.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  //console.log(tweets);\r\n  return tweets;\r\n}\r\n\r\nexport default useTweets;\r\n\r\n"]},"metadata":{},"sourceType":"module"}